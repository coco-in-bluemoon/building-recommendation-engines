3장: 추천 엔진 이해
=================================

# 1. 추천 엔진의 발전
- 최근접 이웃 기반의 추천 → 개인화 추천 → 모델 기반의 추천
- 빅데이터 환경에서의 실시간성이 강조된느 추천 시스템으로 발전


# 2. 최근접 이웃 기반의 추천(Collaborative Filtering)
- 사용자 또는 아이템을 기준으로 최근접 이웃을 찾는다.
- 장점: 1) 구현하기 쉽다. 2) 사용자나 콘텐츠 프로파일을 구축할 필요가 없다. 3) 일반적으로 우연성에 있어서 효과가 좋다
- 단점: 1) 유사도 계산에 많은 시간이 걸린다. 2) 사용자의 아이템 평가 정보가 없는 Cold Start 문제에 취약하다

## 1) 사용자 기반 협업 필터링(User Collaborative Filtering)
- 사용자의 아이템 선호가 시간과 상관없이 일정할 것이라고 가정한다.
- 사용자의 아이템 평가를 기준으로 사용자와 사용자의 유사도를 계산한다.
  - 유사도 계산으로는 유클리드 거리, 피어슨 상관계수, 코사인 유사도가 있다.
  - R과 Python에서 피어슨 상관계수를 처리하는 방식으로 인해 실행 결과에 차이 발생
- 가장 유사한 사용자의 평가 데이터를 기반으로 추천한다. [Python 구현](./python/user_cf.py)

## 2) 아이템 기반 협업 필터링(Item Collaboratie Filtering)
- 사용자의 아이템 평가를 기준으로 아이템과 아이템의 유사도를 계산한다.
- 사용자가 평가한 아이템을 기준으로 다른 아이템과의 유사도를 통해 추천이 이루어진다. [Python 구현](./python/item_cf.py)


# 3. 콘텐츠 기반 추천(Content Based)
- 사용자의 아이템 평점이 아니라 사용자와 아이템의 프로파일을 구축. 프로파일은 콘텐츠의 특징(취향)과 관련됨
- 사용자 프로파일과 아이템 프로파일 사이의 코사인 유사도를 구함
  - 유사도가 높을수록 사용자가 해당 아이템을 선호할 가능성이 높음(유사도가 높다 == 취향이 겹친다)
- 장점: 1) Cold Start 문제를 해결할 수 있다. 2) 사용자의 선호도 정보만으로 추천 결과 생성할 수 있다.(개인화 추천 가능)
- 단점: 1) 우연성이 떨어진다. 2) 프로파일 구축 과정이 필요하다.

### 콘텐츠 기반 추천을 위한 프로파일 구축 방법 
- 아이템 프로파일을 구축하기 위해서는 TF-IDF를 사용.
  - 개별 아이템을 아이템x취향 행렬로 만들고 TF-IDF 변환
- 사용자 프로파일을 구축하기 위해서는 행렬 연산 사용.
  - 사용자x아이템 행렬과 아이템x취향 행렬을 곱하면 사용자x취향 행렬을 구할 수 있음.
  - 사용자x취향 행렬이 사용자 프로파일 [Python 구현](./python/cb.py)

# 4. 상황 인식 추천 시스템
- 시간, 장소와 같이 상황에 대한 정보를 추가하여서 추천
- 사전 필터링 방식과 사후 필터링 방식으로 구분
  - 사전 필터링 방식: 프로파일을 구축하는 과정에서 상황 정보를 사용해서 필터링
  - 사후 필터링 방식: 추천된 결과 중에서 상황에 맞는 결과를 필터링
- 장점: 1) 상황에 따른 정교하고 실시간 추천 가능
- 단점: 1) 우연성이 떨이진다. [Python 구현](./python/situation.py) 


# 5. 하이브리드 추천 시스템 (Hybrid Recommender System)
- Hybrid Recommender = Collaborative Filtering + Content Based
- 각 모델의 장점을 극대화하고 단점을 보완한다.


# 6. 모델 기반 추천 시스템
- CF, CB 방식 모두 메모리 기반의 추천 시스템으로 유사도 계산과 같은 연산이 많이 필요
- 빅 데이터를 처리하고 실시간으로 추천 결과를 생성하기 위해서 모델 기반의 접근 방식 사용 (머신 러닝과 결합)
- 확률적 접근, 머신 러닝 접근, 수학적 접근(행렬 분해)와 같은 방식으로 이루어짐
- 장점: 1) 정교한 추천 시스템 구현 가능


### ☪︎ R의 cor() 함수와 Python의 corr() pandas 함수의 결과가 다르다?
```
- R의 cor() 함수 인자로 complete.all이 주어진다.
- 이러한 경우 테이블에서 NA를 가지고 있는 모든 행이 제거된 NA가 없는 테이블을 먼저 생성하고 이를 기반으로 상관계수를 구한다.
- 반면 Python pandas의 corr()은 두 벡터의 상관계수를 구할 때 결측치만 제거한다.
- 결론적으로 R의 cor() 함수는 Python corr() 함수보다 작은 크기의 벡터에 대해서 상관계수를 구한다.
```