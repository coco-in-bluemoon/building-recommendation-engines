3장: 추천 엔진 이해
=================================

# 1. 추천 엔진의 발전
- 최근접 이웃 기반의 추천 → 개인화 추천 → 모델 기반의 추천
- 빅데이터 환경에서의 실시간성이 강조된느 추천 시스템으로 발전

# 2. 최근접 이웃 기반의 추천(Collaborative Filtering)
- 사용자 또는 아이템을 기준으로 최근접 이웃을 찾는다.
- 장점: 1) 구현하기 쉽다. 2) 사용자나 콘텐츠 프로파일을 구축할 필요가 없다. 3) 일반적으로 우연성에 있어서 효과가 좋다
- 단점: 1) 유사도 계산에 많은 시간이 걸린다. 2) 사용자의 아이템 평가 정보가 없는 Cold Start 문제에 취약하다

## 1) 사용자 기반 협업 필터링(User Collaborative Filtering)
- 사용자의 아이템 선호가 시간과 상관없이 일정할 것이라고 가정한다.
- 사용자의 아이템 평가를 기준으로 사용자와 사용자의 유사도를 계산한다.
  - 유사도 계산으로는 유클리드 거리, 피어슨 상관계수, 코사인 유사도가 있다.
  - R과 Python에서 피어슨 상관계수를 처리하는 방식으로 인해 실행 결과에 차이 발생
- 가장 유사한 사용자의 평가 데이터를 기반으로 추천한다. [Python 구현](./python/user_cf.py)

## 2) 아이템 기반 협업 필터링(Item Collaboratie Filtering)
- 사용자의 아이템 평가를 기준으로 아이템과 아이템의 유사도를 계산한다.
- 사용자가 평가한 아이템을 기준으로 다른 아이템과의 유사도를 통해 추천이 이루어진다.


### ☪︎ R의 cor() 함수와 Python의 corr() pandas 함수의 결과가 다르다?
```
- R의 cor() 함수 인자로 complete.all이 주어진다.
- 이러한 경우 테이블에서 NA를 가지고 있는 모든 행이 제거된 NA가 없는 테이블을 먼저 생성하고 이를 기반으로 상관계수를 구한다.
- 반면 Python pandas의 corr()은 두 벡터의 상관계수를 구할 때 결측치만 제거한다.
- 결론적으로 R의 cor() 함수는 Python corr() 함수보다 작은 크기의 벡터에 대해서 상관계수를 구한다.
```